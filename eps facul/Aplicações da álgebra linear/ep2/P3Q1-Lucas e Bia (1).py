# -*- coding: utf-8 -*-
"""Cópia de p3q1_aal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PyyvC1HsA-GNyiY8oqToW3u5lDQhvShW
"""
#### RODAR NO TERMINAL:
#pip install magic_square
# ----

import scipy.linalg as sl
import numpy as np
from itertools import permutations
import magic_square as ms
import time
import pandas as pd
import matplotlib.pyplot as plt


##############Funções auxiliares
def norm(v): #norma - matrizes ou vetores
  return np.linalg.norm(v)

def cond(X): # número de condição da matriz
  return np.linalg.cond(X)


##############Funções auxiliares para householder


def mathouseholder(v):# matriz Hv de um vetor
    dim = len(v)
    v = np.array(v)
    v.shape = (dim,1)
    num = np.transpose(v).dot(v)[0,0]
    mat = v.dot(np.transpose(v))
    #print(mat)
    i = np.eye(dim)
    Hv = i - (2/num)*(mat)
    return Hv

def reduz(X,n): # matriz reduzida
  return X[n:,n:]

def ajustaQ(tam,Q): # matriz ajustada
  tq = len(Q)
  dif = tam-tq
  ajust = np.zeros((tam,tam))
  ajust[:dif,:dif] = np.eye(dif)
  ajust[dif:,dif:] = Q
  return ajust


#########################
##### FATORAÇÕES ########
#########################

######################### Gram - Schmidt clássico

# "traduzi" do blog
def gs(X):
  n,p = len(X),len(X[0])
  Q = np.zeros((n,p))
  R = np.zeros((p,p))
  for k in range(p):
    Q[:,k]=X[:,k]
    if k != 0:
      R[1:k-1,k] = np.dot(Q[:,k-1],Q[:,k])
      Q[:,k] = Q[:,k] - np.dot(Q[:,1:k-1],R[1:k-1,k])
    R[k,k] = norm(Q[:,k])
    Q[:,k] = Q[:,k]/R[k,k]
  
  return Q,R

######################### Gram - Schmidt modificado

# "traduzi" do blog

def mgs(X): # FATORAÇÃO
  n,p = len(X),len(X[0])
  Q = np.zeros((n,p))
  R = np.zeros((p,p))
  for k in range(p):
    Q[:,k]=X[:,k]
    for i in range(k-1):
      R[i,k] = np.dot(Q[:,i],Q[:,k])
      Q[:,k] = Q[:,k] -  R[i,k] * Q[:,i]
    R[k,k] = norm(Q[:,k])
    Q[:,k] = Q[:,k]/R[k,k]
  return Q,R

######################### Fatoracao por reflexoes de householder

# programei a partir de um algorítmo da wikipédia

def HH(X):
  n,p = len(X),len(X[0])
  LH = []
  m = min(n,p)
  XN=X
  for k in range(m-1):
    A = reduz(XN,k)
    x = A[:,0]
    a = norm(x)
    aek = np.array([a] + [0]*(len(x)-1))
    u = x-aek
    v = u
    Q = mathouseholder(v)
    Q = ajustaQ(n,Q)
    LH.append(Q)
    XN = np.dot(Q,XN)

  taml=len(LH)
  Q = np.transpose(LH[0])
  for i in range(taml-1):
    Q = np.dot(Q,np.transpose(LH[i+1]))
  R = np.dot(np.transpose(Q),X)
  #if not np.allclose(R,XN): print('ERRO: R != XN')
  return Q,R

#########################
######## TESTES #########
#########################


# testa uma lista de matrizes Xs
def testeLista(Xs):
  d = {#'tipo da matriz':[],
       'ordem da matriz':[],
       'número de condição':[],
       'GS:|X - QR|':[],
       'MGS:|X - QR|':[],
       'HH:|X - QR|':[],
       'GS:|QtQ - I|':[],
       'MGS:|QtQ - I|':[],
       'HH:|QtQ - I|':[],
       'GS: tempo gasto':[],
       'MGS: tempo gasto':[],
       'HH: tempo gasto':[]
       #'memória gasta':[],
       }

  for X in Xs:
    n = X.shape[0]
    I = np.eye(n)
    #d['tipo da matriz'].append(Mtype)
    d['ordem da matriz'].append(n)
    d['número de condição'].append(cond(X))

    #### GS
    start = time.time()
    Q,R = gs(X)
    end = time.time()
    QR = np.dot(Q,R)
    QtQ = np.dot(np.transpose(Q),Q)
    E1 = norm(X - QR) # erro 1 - |X - QR|
    E2 = norm(QtQ - I) # erro 2 - |QtQ - I|
    T = end - start # tempo de execução
    d['GS:|X - QR|'].append(E1)
    d['GS:|QtQ - I|'].append(E2)
    d['GS: tempo gasto'].append(T)
    
    #### MGS
    start = time.time()
    Q,R = mgs(X)
    end = time.time()
    QR = np.dot(Q,R)
    QtQ = np.dot(np.transpose(Q),Q)
    E1 = norm(X - QR)
    E2 = norm(QtQ - I)
    T = end - start
    d['MGS:|X - QR|'].append(E1)
    d['MGS:|QtQ - I|'].append(E2)
    d['MGS: tempo gasto'].append(T)

    #### HH
    start = time.time()
    Q,R = HH(X)
    end = time.time()
    QR = np.dot(Q,R)
    QtQ = np.dot(np.transpose(Q),Q)
    E1 = norm(X - QR)
    E2 = norm(QtQ - I)
    T = end - start
    d['HH:|X - QR|'].append(E1)
    d['HH:|QtQ - I|'].append(E2)
    d['HH: tempo gasto'].append(T)

  return pd.DataFrame(d)

# gera matriz de hilbert nxn
def Hilbert(n):
  M = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      q = i+j+1
      M[i,j] = 1/q
  return M

# gera quadrado mágico de ordem n
def Magic(n):
  return ms.magic(n)

def testesFinais(): # testa matrizes de hilbert e quadrado mágico
  lmagic = []
  lhilbert = []
  for i in list(range(50,1050,50)):
    lmagic.append(Magic(i))
    lhilbert.append(Hilbert(i))
  TM = testeLista(lmagic)
  TH = testeLista(lhilbert)
  return TM,TH 
  # TM = dataframe com os resultados das matrizes mágicas
  # TH = dataframe com os resultados das matrizes de Hilbert

def main():
    TM,TH = testesFinais()
    
    x = TM['ordem da matriz']
    yH = TH['número de condição']
    yM = TM['número de condição']
    
    plt.figure() # plot - ordem X condição
    plt.plot(x,yM,label='magic',linewidth= 1.1,c='b')
    plt.plot(x,yH,label='Hilbert',linewidth= 1.1,c='r')
    plt.xlabel('Ordem')
    plt.ylabel('Numero de condicao')
    plt.legend()
    
    plots_df(TM)
    plots_df(TH)
    
    
    
def plots_df(df):
    T = df.copy()
    
    # plot 1 - tempo x ordem
    
    x = T['ordem da matriz']
    y1 = T['GS: tempo gasto']
    y2 = T['MGS: tempo gasto']
    y3 = T['HH: tempo gasto']
    plt.figure()
    plt.plot(x,y1,label='GS',linewidth= 1.1,c='b')
    plt.plot(x,y2,label='MGS',linewidth= 1.1,c='g')
    plt.plot(x,y3,label='HH',linewidth= 1.1,c='r')
    plt.xlabel('Ordem')
    plt.ylabel('Tempo gasto')
    plt.legend()
    
    # plot 2 - erro de ortogonalização x ordem
    
    x = T['ordem da matriz']
    y1 =  T['GS:|QtQ - I|']
    y2 = T['MGS:|QtQ - I|']
    y3 =  T['HH:|QtQ - I|']
    plt.figure()
    plt.plot(x,y1,label='GS',linewidth= 1.1,c='b')
    plt.plot(x,y2,label='MGS',linewidth= 1.1,c='g')
    plt.plot(x,y3,label='HH',linewidth= 1.1,c='r')
    plt.xlabel('Ordem')
    plt.ylabel('|QtQ - I|')
    plt.legend()
    
    # plot 3 - erro na matriz x ordem
    
    x = T['ordem da matriz']
    y1 =  T['GS:|X - QR|']
    y2 = T['MGS:|X - QR|']
    y3 =  T['HH:|X - QR|']
    plt.figure()
    plt.plot(x,y1,label='GS',linewidth= 1.1,c='b')
    plt.plot(x,y2,label='MGS',linewidth= 1.1,c='g')
    plt.plot(x,y3,label='HH',linewidth= 1.1,c='r')
    plt.xlabel('Ordem')
    plt.ylabel('|X - QR|')
    plt.legend()
